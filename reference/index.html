<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Namespaces - Deedle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="BlueMountain Capital, FsLab.Org">

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">

    <link type="text/css" rel="stylesheet" href="https://fslab.org/Deedle/content/style.css" />
    <link type="text/css" rel="stylesheet" href="https://fslab.org/Deedle/content/deedle.css" />
    <script type="text/javascript" src="https://fslab.org/Deedle/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://fsharp.org">fsharp.org</a></li>
          <li><a href="http://fslab.org/RProvider"><img height=" 16" width="16" src="http://fsharp.org/images/thumbs/FSharpRProvider.png" /> R Provider</a></li>
          <li><a href="https://fslab.org/FSharp.Charting/"><img height="16" width="16" src="http://fsharp.org/images/thumbs/FSharp.Charting.png" /> F# Charting</a></li>
          <li><a href="http://fsharp.github.io/FSharp.Data"><img height="16" width="16" src="http://fsharp.org/images/thumbs/FSharp.Data.png" /> F# Data</a></li>
          <li><a href="http://fsprojects.github.io/FSharp.Data.Toolbox"><img height="16" width="16" src="http://fsharp.org/images/thumbs/FSharp.Data.Toolbox.png" /> F# Data Toolbox</a></li>
        </ul>
        <h3 class="muted"><a href="https://fslab.org/Deedle/index.html">Deedle</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          

<h1>Deedle</h1>


  <h2>Deedle Namespace</h2>
    <!-- If there is more than 1 category in the type, generate TOC -->
    <ul>
        <li><a href="#section1_0">Core frame and series types</a></li>            
        <li><a href="#section1_1">Frame and series operations</a></li>            
        <li><a href="#section1_2">Parameters and results of various operations</a></li>            
        <li><a href="#section1_3">Primitive types and values</a></li>            
        <li><a href="#section1_4">Specialized frame and series types</a></li>            
        <li><a href="#section1_5">Vectors and indices</a></li>            
        <li><a href="#section1_6">Other namespace members</a></li>            
    </ul>
      <h3><a class="anchor" name="section1_0" href="#section1_0">Core frame and series types</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-frame-2.html">Frame<'TRowKey, 'TColumnKey></a>
          </td>
          <td class="xmldoc">
          <p>A frame is the key Deedle data structure (together with series). It represents a
data table (think spreadsheet or CSV file) with multiple rows and columns. The frame
consists of row index, column index and data. The indices are used for efficient
lookup when accessing data by the row key <code>'TRowKey</code> or by the column key
<code>'TColumnKey</code>. Deedle frames are optimized for the scenario when all values in a given
column are of the same type (but types of different columns can differ).</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-framedata.html">FrameData</a>
          </td>
          <td class="xmldoc">
          <p>Represents the underlying (raw) data of the frame in a format that can
be used for exporting data frame to other formats etc. (DataTable, CSV, Excel)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-iseries-1.html">ISeries<'K></a>
          </td>
          <td class="xmldoc">
          <p>Represents an untyped series with keys of type <code>K</code> and values of some unknown type
(This type should not generally be used directly, but it can be used when you need
to write code that works on a sequence of series of heterogeneous types).</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-series-2.html">Series<'K, 'V></a>
          </td>
          <td class="xmldoc">
          <p>The type <code>Series&lt;K, V&gt;</code> represents a data series consisting of values <code>V</code> indexed by
keys <code>K</code>. The keys of a series may or may not be ordered</p>


          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-f__series_extensions.html">F# Series extensions</a>
          </td>
          <td class="xmldoc">
          <p>Contains extensions for creating values of type <code>Series&lt;'K, 'V&gt;</code> including
a type with functions such as <code>Series.ofValues</code> and the <code>series</code> function.
The module is automatically opened for all F# code that references <code>Deedle</code>.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section1_1" href="#section1_1">Frame and series operations</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-enumerableextensions.html">EnumerableExtensions</a>
          </td>
          <td class="xmldoc">
          <p>Contains C#-friendly extension methods for various instances of <code>IEnumerable</code>
that can be used for creating <code>Series&lt;'K, 'V&gt;</code> from the <code>IEnumerable</code> value.
You can create an ordinal series from <code>IEnumerable&lt;'T&gt;</code> or an indexed series from
<code>IEnumerable&lt;KeyValuePair&lt;'K, 'V&gt;&gt;</code> or from <code>IEnumerable&lt;KeyValuePair&lt;'K, OptionalValue&lt;'V&gt;&gt;&gt;</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-frame.html">Frame</a>
          </td>
          <td class="xmldoc">
          <p>Provides static methods for creating frames, reading frame data
from CSV files and database (via IDataReader). The type also provides
global configuration for reflection-based expansion.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-frameextensions.html">FrameExtensions</a>
          </td>
          <td class="xmldoc">
          <p>Contains C# and F# extension methods for the <code>Frame&lt;'R, 'C&gt;</code> type. The members are
automatically available when you import the <code>Deedle</code> namespace. The type contains
object-oriented counterparts to most of the functionality from the <code>Frame</code> module.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-seriesextensions.html">SeriesExtensions</a>
          </td>
          <td class="xmldoc">
          <p>The type implements C# and F# extension methods for the <code>Series&lt;'K, 'V&gt;</code> type.
The members are automatically available when you import the <code>Deedle</code> namespace.
The type contains object-oriented counterparts to most of the functionality
from the <code>Series</code> module.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-seriesstatsextensions.html">SeriesStatsExtensions</a>
          </td>
          <td class="xmldoc">
          <p>The type implements C# and F# extension methods that add numerical operations
to Deedle series. With a few exceptions, the methods are only available for
series containing floating-point values, that is <code>Series&lt;'K, float&gt;</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-stats.html">Stats</a>
          </td>
          <td class="xmldoc">
          <p>The <code>Stats</code> type contains functions for fast calculation of statistics over
series and frames as well as over a moving and an expanding window in a series.</p>
<p>The resulting series has the same keys as the input series. When there are
no values, or missing values, different functions behave in different ways.
Statistics (e.g. mean) return missing value when any value is missing, while min/max
functions return the minimal/maximal element (skipping over missing values).</p>


          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-f__frame_extensions.html">F# Frame extensions</a>
          </td>
          <td class="xmldoc">
          <p>This module contains F# functions and extensions for working with frames. This
includes operations for creating frames such as the <code>frame</code> function, <code>=&gt;</code> operator
and <code>Frame.ofRows</code>, <code>Frame.ofColumns</code> and <code>Frame.ofRowKeys</code> functions. The module
also provides additional F# extension methods including <code>ReadCsv</code>, <code>SaveCsv</code> and <code>PivotTable</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-framemodule.html">Frame</a>
          </td>
          <td class="xmldoc">
          <p>The <code>Frame</code> module provides an F#-friendly API for working with data frames.
The module follows the usual desing for collection-processing in F#, so the
functions work well with the pipelining operator (<code>|&gt;</code>). For example, given
a frame with two columns representing prices, we can use <code>Frame.diff</code> and
numerical operators to calculate daily returns like this:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">df</span> <span class="o">=</span> <span class="id">frame</span> <span class="pn">[</span> <span class="s">&quot;MSFT&quot;</span> <span class="o">=&gt;</span> <span class="id">prices1</span><span class="pn">;</span> <span class="s">&quot;AAPL&quot;</span> <span class="o">=&gt;</span> <span class="id">prices2</span> <span class="pn">]</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="id">past</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs1', 3)" onmouseover="showTip(event, 'fs1', 3)" class="id">df</span> <span class="o">|&gt;</span> <span class="id">Frame</span><span class="pn">.</span><span class="id">diff</span> <span class="n">1</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs3', 4)" onmouseover="showTip(event, 'fs3', 4)" class="id">rets</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs2', 5)" onmouseover="showTip(event, 'fs2', 5)" class="id">past</span> <span class="o">/</span> <span onmouseout="hideTip(event, 'fs1', 6)" onmouseover="showTip(event, 'fs1', 6)" class="id">df</span> <span class="o">*</span> <span class="n">100.0</span>
<span onmouseout="hideTip(event, 'fs3', 7)" onmouseover="showTip(event, 'fs3', 7)" class="id">rets</span> <span class="o">|&gt;</span> <span class="id">Stats</span><span class="pn">.</span><span class="id">mean</span>
</code></pre></td>
</tr>
</table>
<p>Note that the <code>Stats.mean</code> operation is overloaded and works both on series
(returning a number) and on frames (returning a series).</p>
<p>The functions in this module are designed to be used from F#. For a C#-friendly
API, see the <code>FrameExtensions</code> type. For working with individual series, see the
<code>Series</code> module. The functions in the <code>Frame</code> module are grouped in a number of
categories and documented below.</p>
<div class="tip" id="fs1">val df : float</div>
<div class="tip" id="fs2">val past : float</div>
<div class="tip" id="fs3">val rets : float</div>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-framebuilder.html">FrameBuilder</a>
          </td>
          <td class="xmldoc">
          <p>Type that can be used for creating frames using the C# collection initializer syntax.
You can use <code>new FrameBuilder.Columns&lt;...&gt;</code> to create a new frame from columns or you
can use <code>new FrameBuilder.Rows&lt;...&gt;</code> to create a new frame from rows.</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-seriesmodule.html">Series</a>
          </td>
          <td class="xmldoc">
          <p>The <code>Series</code> module provides an F#-friendly API for working with data and time series.
The API follows the usual design for collection-processing in F#, so the functions work
well with the pipelining (<code>|&gt;</code>) operator. For example, given a series with ages,
we can use <code>Series.filterValues</code> to filter outliers and then <code>Stats.mean</code> to calculate
the mean:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="id">ages</span>
<span class="o">|&gt;</span> <span class="id">Series</span><span class="pn">.</span><span class="id">filterValues</span> <span class="pn">(</span><span class="k">fun</span> <span class="id">v</span> <span class="k">-&gt;</span> <span class="id">v</span> <span class="pn">&gt;</span> <span class="n">0.0</span> <span class="o">&amp;&amp;</span> <span class="id">v</span> <span class="pn">&lt;</span> <span class="n">120.0</span><span class="pn">)</span>
<span class="o">|&gt;</span> <span class="id">Stats</span><span class="pn">.</span><span class="id">mean</span>
</code></pre></td>
</tr>
</table>
<p>The module provides comprehensive set of functions for working with series. The same
API is also exposed using C#-friendly extension methods. In C#, the above snippet could
be written as:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">ages
  .Where(kvp <span class="o">=</span><span class="o">&gt;</span> kvp.Value <span class="o">&gt;</span> <span class="n">0.0</span> <span class="o">&amp;</span><span class="o">&amp;</span> kvp.Value <span class="o">&lt;</span> <span class="n">120.0</span>)
  .Mean()
</code></pre></td></tr></table>
<p>For more information about similar frame-manipulation functions, see the <code>Frame</code> module.
For more information about C#-friendly extensions, see <code>SeriesExtensions</code>. The functions
in the <code>Series</code> module are grouped in a number of categories and documented below.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section1_2" href="#section1_2">Parameters and results of various operations</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-aggregation-1.html">Aggregation<'K></a>
          </td>
          <td class="xmldoc">
          <p>Represents a strategy for aggregating data in an ordered series into data segments.
To create a value of this type from C#, use the non-generic <a href="deedle-aggregation.html" title="Aggregation"><code>Aggregation</code></a> type.
Data can be aggregate using floating windows or chunks of a specified size or
by specifying a condition on two keys (i.e. end a window/chunk when the condition
no longer holds).</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-aggregation.html">Aggregation</a>
          </td>
          <td class="xmldoc">
          <p>A non-generic type that simplifies the construction of <code>Aggregation&lt;K&gt;</code> values
from C#. It provides methods for constructing different kinds of aggregation
strategies for ordered series.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-boundary.html">Boundary</a>
          </td>
          <td class="xmldoc">
          <p>Represents boundary behaviour for operations such as floating window. The type
specifies whether incomplete windows (of smaller than required length) should be
produced at the beginning (<code>AtBeginning</code>) or at the end (<code>AtEnding</code>) or
skipped (<code>Skip</code>). For chunking, combinations are allowed too - to skip incomplete
chunk at the beginning, use <code>Boundary.Skip ||| Boundary.AtBeginning</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-conversionkind.html">ConversionKind</a>
          </td>
          <td class="xmldoc">
          <p>Represents different kinds of type conversions that can be used by Deedle internally.
This is used, for example, when converting <code>ObjectSeries&lt;'K&gt;</code> to <code>Series&lt;'K, 'T&gt;</code> -
The conversion kind can be specified as an argument to allow certain conversions.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-datasegment-1.html">DataSegment<'T></a>
          </td>
          <td class="xmldoc">
          <p>Represents a segment of a series or sequence. The value is returned from
various functions that aggregate data into chunks or floating windows. The
<code>Complete</code> case represents complete segment (e.g. of the specified size) and
<a href="deedle-boundary.html" title="Boundary"><code>Boundary</code></a> represents segment at the boundary (e.g. smaller than the required
size).</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-datasegmentkind.html">DataSegmentKind</a>
          </td>
          <td class="xmldoc">
          <p>Represents a kind of <code>DataSegment&lt;T&gt;</code>. See that type for more information.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-direction.html">Direction</a>
          </td>
          <td class="xmldoc">
          <p>Specifies in which direction should we look when performing operations such as
<code>Series.Pairwise</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-icustomlookup-1.html">ICustomLookup<'K></a>
          </td>
          <td class="xmldoc">
          <p>Represents a special lookup. This can be used to support hierarchical or duplicate keys
in an index. A key type <code>K</code> can come with associated <code>ICustomLookup&lt;K&gt;</code> to provide
customized pattern matching (equality testing)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-joinkind.html">JoinKind</a>
          </td>
          <td class="xmldoc">
          <p>This enumeration specifies joining behavior for <code>Join</code> method provided
by <code>Series</code> and <code>Frame</code>. Outer join unions the keys (and may introduce
missing values), inner join takes the intersection of keys; left and
right joins take the keys of the first or the second series/frame.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-lookup.html">Lookup</a>
          </td>
          <td class="xmldoc">
          <p>Represents different behaviors of key lookup in series. For unordered series,
the only available option is <code>Lookup.Exact</code> which finds the exact key - methods
fail or return missing value if the key is not available in the index. For ordered
series <code>Lookup.Greater</code> finds the first greater key (e.g. later date) with
a value. <code>Lookup.Smaller</code> searches for the first smaller key. The options
<code>Lookup.ExactOrGreater</code> and <code>Lookup.ExactOrSmaller</code> finds the exact key (if it is
present) and otherwise search for the nearest larger or smaller key, respectively.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-unionbehavior.html">UnionBehavior</a>
          </td>
          <td class="xmldoc">
          <p>This enumeration specifies the behavior of <code>Union</code> operation on series when there are
overlapping keys in two series that are being unioned. The options include preferring values
from the left/right series or throwing an exception when both values are available.</p>


          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-datasegment.html">DataSegment</a>
          </td>
          <td class="xmldoc">
          <p>Provides helper functions and active patterns for working with <a href="deedle-datasegment.html" title="DataSegment"><code>DataSegment</code></a> values</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-multikeyextensions.html">MultiKeyExtensions</a>
          </td>
          <td class="xmldoc">
          <p>F#-friendly functions for creating multi-level keys and lookups</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section1_3" href="#section1_3">Primitive types and values</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-keyvalue.html">KeyValue</a>
          </td>
          <td class="xmldoc">
          <p>A type with extension method for <code>KeyValuePair&lt;'K, 'V&gt;</code> that makes
it possible to create values using just <code>KeyValue.Create</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-missingvalueexception.html">MissingValueException</a>
          </td>
          <td class="xmldoc">
          <p>Thrown when a value at the specified index does not exist in the data frame or series.
This exception is thrown only when the key is defined, but the value is not available,
in other situations <code>KeyNotFoundException</code> is thrown</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-optionalvalue-1.html">OptionalValue<'T></a>
          </td>
          <td class="xmldoc">
          <p>Value type that represents a potentially missing value. This is similar to
<code>System.Nullable&lt;T&gt;</code>, but does not restrict the contained value to be a value
type, so it can be used for storing values of any types. When obtained from
<code>DataFrame&lt;R, C&gt;</code> or <code>Series&lt;K, T&gt;</code>, the <code>Value</code> will never be <code>Double.NaN</code> or <code>null</code>
(but this is not, in general, checked when constructing the value).</p>
<p>The type is only used in C#-friendly API. F# operations generally use expose
standard F# <code>option&lt;T&gt;</code> type instead. However, there the <a href="deedle-optionalvalue.html" title="OptionalValue"><code>OptionalValue</code></a> module
contains helper functions for using this type from F# as well as <code>Missing</code> and
<code>Present</code> active patterns.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-optionalvalue.html">OptionalValue</a>
          </td>
          <td class="xmldoc">
          <p>Non-generic type that makes it easier to create <code>OptionalValue&lt;T&gt;</code> values
from C# by benefiting the type inference for generic method invocations.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-optionalvalueextensions.html">OptionalValueExtensions</a>
          </td>
          <td class="xmldoc">
          <p>Extension methods for working with optional values from C#. These make
it easier to provide default values and convert optional values to
<code>Nullable</code> (when the contained value is value type)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-tryvalue-1.html">TryValue<'T></a>
          </td>
          <td class="xmldoc">
          <p>Represents a value or an exception. This type is used by functions such as
<code>Series.tryMap</code> and <code>Frame.tryMap</code> to capture the result of a lambda function,
which may be either a value or an exception. The type is a discriminated union,
so it can be processed using F# pattern matching, or using <code>Value</code>, <code>HasValue</code>
and <code>Exception</code> properties</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-opt-1.html">opt<'T></a>
          </td>
          <td class="xmldoc">
          <p>A type alias for the <code>OptionalValue&lt;T&gt;</code> type. The type alias can be used
to make F# type definitions that use optional values directly more succinct.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-tryval-1.html">tryval<'T></a>
          </td>
          <td class="xmldoc">
          <p>A type alias for the <code>TryValue&lt;T&gt;</code> type. The type alias can be used
to make F# type declarations that explcitly handle exceptions more succinct.</p>


          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-optionalvaluemodule.html">OptionalValue</a>
          </td>
          <td class="xmldoc">
          <p>Provides various helper functions for using the <code>OptionalValue&lt;T&gt;</code> type from F#
(The functions are similar to those in the standard <code>Option</code> module).</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-pair.html">Pair</a>
          </td>
          <td class="xmldoc">
          <p>Module with helper functions for extracting values from hierarchical tuples</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section1_4" href="#section1_4">Specialized frame and series types</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-columnseries-2.html">ColumnSeries<'TRowKey, 'TColumnKey></a>
          </td>
          <td class="xmldoc">
          <p>Represents a series of columns from a frame. The type inherits from a series of
series representing individual columns (<code>Series&lt;'TColumnKey, ObjectSeries&lt;'TRowKey&gt;&gt;</code>) but
hides slicing operations with new versions that return frames.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-delayedseries.html">DelayedSeries</a>
          </td>
          <td class="xmldoc">
          <p>This type exposes a single static method <code>DelayedSeries.Create</code> that can be used for
constructing data series (of type <code>Series&lt;K, V&gt;</code>) with lazily loaded data. You can
use this functionality to create series that represents e.g. an entire price history
in a database, but only loads data that are actually needed. For more information
see the <a href="../lazysource.html">lazy data loading tutorial</a>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-iframe.html">IFrame</a>
          </td>
          <td class="xmldoc">
          <p>An empty interface that is implemented by <code>Frame&lt;'R, 'C&gt;</code>. The purpose of the
interface is to allow writing code that works on arbitrary data frames (you
need to provide an implementation of the <code>IFrameOperation&lt;'V&gt;</code> which contains
a generic method <code>Invoke</code> that will be called with the typed data frame).</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-iframeoperation-1.html">IFrameOperation<'V></a>
          </td>
          <td class="xmldoc">
          <p>Represents an operation that can be invoked on <code>Frame&lt;'R, 'C&gt;</code>. The operation
is generic in the type of row and column keys.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-objectseries-1.html">ObjectSeries<'K></a>
          </td>
          <td class="xmldoc">
          <p>Represents a series containing boxed values. This type is inherited from <code>Series&lt;'K, obj&gt;</code>
and it adds additional operations for accessing values with unboxing. This includes operations
such as <code>os.GetAs&lt;'T&gt;</code>, <code>os.TryGetAs&lt;'T&gt;</code> and <code>os.TryAs&lt;'T&gt;</code> which (attempt to) convert
values to the specified type <code>'T</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-rowseries-2.html">RowSeries<'TRowKey, 'TColumnKey></a>
          </td>
          <td class="xmldoc">
          <p>Represents a series of rows from a frame. The type inherits from a series of
series representing individual rows (<code>Series&lt;'TRowKey, ObjectSeries&lt;'TColumnKey&gt;&gt;</code>) but
hides slicing operations with new versions that return frames.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-seriesbuilder-2.html">SeriesBuilder<'K, 'V></a>
          </td>
          <td class="xmldoc">
          <p>The type can be used for creating series using mutation. You can add
items using <code>Add</code> and get the resulting series using the <code>Series</code> property.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-seriesbuilder-1.html">SeriesBuilder<'K></a>
          </td>
          <td class="xmldoc">
          <p>A simple class that inherits from <code>SeriesBuilder&lt;'K, obj&gt;</code> and can be
used instead of writing <code>SeriesBuilder&lt;'K, obj&gt;</code> with two type arguments.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section1_5" href="#section1_5">Vectors and indices</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-ivector.html">IVector</a>
          </td>
          <td class="xmldoc">
          <p>Represents an (untyped) vector that stores some values and provides access
to the values via a generic address. This type should be only used directly when
extending the DataFrame library and adding a new way of storing or loading data.
To allow invocation via Reflection, the vector exposes type of elements as <code>System.Type</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-ivector-1.html">IVector<'T></a>
          </td>
          <td class="xmldoc">
          <p>A generic, typed vector. Represents mapping from addresses to values of type <code>T</code>.
The vector provides a minimal interface that is required by series and can be
implemented in a number of ways to provide vector backed by database or an
alternative representation of data.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-ivectorlocation.html">IVectorLocation</a>
          </td>
          <td class="xmldoc">
          <p>Represents a location in a vector. In general, we always know the address, but
sometimes (BigDeedle) it is hard to get the offset (requires some data lookups),
so we use this interface to delay the calculation of the Offset (which is mainly
needed in one of the <code>series.Select</code> overloads)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-index.html">Index</a>
          </td>
          <td class="xmldoc">
          <p>Type that provides access to creating indices (represented as <code>LinearIndex</code> values)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectorcallsite-1.html">VectorCallSite<'R></a>
          </td>
          <td class="xmldoc">
          <p>Represents a generic function <code>\forall.'T.(IVector&lt;'T&gt; -&gt; 'R)</code>. The function can be
generically invoked on an argument of type <a href="deedle-ivector.html" title="IVector"><code>IVector</code></a> using <code>IVector.Invoke</code></p>


          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-addressing.html">Addressing</a>
          </td>
          <td class="xmldoc">
          <p>An <a href="deedle-addressing-address.html" title="Address"><code>Address</code></a> value is used as an interface between vectors and indices. The index maps
keys of various types to address, which is then used to get a value from the vector.</p>
<p>Here is a brief summary of what we assume (and don't assume) about addresses:</p>
<ul>
<li>Address is <code>int64</code> (although we might need to generalize this in the future)</li>
<li>
Different data sources can use different addressing schemes
(as long as both index and vector use the same scheme)
</li>
<li>
Addresses don't have to be continuous (e.g. if the source is partitioned, it
can use 32bit partition index + 32bit offset in the partition)
</li>
<li>In the in-memory representation, address is just index into an array</li>
<li>
In the BigDeedle representation, address is abstracted and comes with
<code>AddressOperations</code> that specifies how to use it (tests use linear
offset and partitioned representation)
</li>
</ul>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-f__index_extensions.html">F# Index extensions</a>
          </td>
          <td class="xmldoc">
          <p>Defines non-generic <code>Index</code> type that provides functions for building indices
(hard-bound to <a href="deedle-indices-linear-linearindexbuilder.html" title="LinearIndexBuilder"><code>LinearIndexBuilder</code></a> type). In F#, the module is automatically opened
using <code>AutoOpen</code>. The methods are not designed for the use from C#.</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-f__indexbuilder_implementation.html">F# IndexBuilder implementation</a>
          </td>
          <td class="xmldoc">
          <p>Set concrete IIndexBuilder implementation</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-f__vector_extensions.html">F# Vector extensions</a>
          </td>
          <td class="xmldoc">
          <p>Defines non-generic <code>Vector</code> type that provides functions for building vectors
(hard-bound to <a href="deedle-vectors-arrayvector-arrayvectorbuilder.html" title="ArrayVectorBuilder"><code>ArrayVectorBuilder</code></a> type). In F#, the module is automatically opened
using <code>AutoOpen</code>. The methods are not designed for the use from C#.</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-f__vector_extensions_(core).html">F# Vector extensions (core)</a>
          </td>
          <td class="xmldoc">
          <p>Module with extensions for generic vector type. Given <code>vec</code> of type <code>IVector&lt;T&gt;</code>,
the extension property <code>vec.DataSequence</code> returns all data of the vector converted
to the "least common denominator" data structure - <code>IEnumerable&lt;T&gt;</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-f__vectorbuilder_implementation.html">F# VectorBuilder implementation</a>
          </td>
          <td class="xmldoc">
          <p>Set concrete IVectorBuilder implementation</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section1_6" href="#section1_6">Other namespace members</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-diff-1.html">Diff<'T></a>
          </td>
          <td class="xmldoc">
          
          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-irangerestriction-1.html">IRangeRestriction<'TAddress></a>
          </td>
          <td class="xmldoc">
          <p>A sequence of indicies together with the total number. Use <code>RangeRestriction.ofSeq</code> to
create one from a sequence. This can be implemented by concrete vector/index
builders to allow further optimizations (e.g. when the underlying source directly
supports range operations).</p>
<p>For example, if your source has an optimised way for getting every 10th address, you
can create your own <code>IRangeRestriction</code> and then check for it in <code>LookupRange</code> and
use optimised implementation rather than actually iterating over the sequence of indices.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-rangerestriction-1.html">RangeRestriction<'TAddress></a>
          </td>
          <td class="xmldoc">
          <p>Specifies a sub-range within index that can be accessed via slicing
(see the <code>GetAddressRange</code> method). For in-memory data structures, accessing
range via known addresses is typically sufficient, but for virtual Big Deedle
sources, <code>Start</code> and <code>End</code> let us avoid fully evaluating addresses.
<code>Custom</code> range can be used for optimizations.</p>


          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-rangerestriction.html">RangeRestriction</a>
          </td>
          <td class="xmldoc">
          <p>Provides additional operations for working with the <code>RangeRestriction&lt;'TAddress&gt;</code> type</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-statsinternal.html">StatsInternal</a>
          </td>
          <td class="xmldoc">
          
          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Indices Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-asyncseriesconstruction-1.html">AsyncSeriesConstruction<'K></a>
          </td>
          <td class="xmldoc">
          <p>Asynchronous version of <code>SeriesConstruction&lt;'K&gt;</code>. Returns a workflow that evaluates
the index, together with a construction to apply (asynchronously) on vectors</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-boundarybehavior.html">BoundaryBehavior</a>
          </td>
          <td class="xmldoc">
          <p>Specifies the boundary behavior for the <code>IIndexBuilder.GetRange</code> operation
(whether the boundary elements should be included or not)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-iindex-1.html">IIndex<'K></a>
          </td>
          <td class="xmldoc">
          <p>An interface that represents index mapping keys of some generic type <code>T</code> to locations
of address <a href="deedle-addressing-address.html" title="Address"><code>Address</code></a>. The <code>IIndex&lt;K&gt;</code> contains minimal set of operations that have to
be supported by an index. This type should be only used directly when
extending the DataFrame library and adding a new way of storing or loading data.
Values of this type are constructed using the associated <a href="deedle-indices-iindexbuilder.html" title="IIndexBuilder"><code>IIndexBuilder</code></a> type.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-iindexbuilder.html">IIndexBuilder</a>
          </td>
          <td class="xmldoc">
          <p>A builder represents various ways of constructing index, either from keys or from
other indices. The operations that build a new index from an existing index also
build <a href="deedle-vectors-vectorconstruction.html" title="VectorConstruction"><code>VectorConstruction</code></a> which specifies how to transform vectors aligned with the
previous index to match the new index. The methods generally take <a href="deedle-vectors-vectorconstruction.html" title="VectorConstruction"><code>VectorConstruction</code></a>
as an input, apply necessary transformations to it and return a new <a href="deedle-vectors-vectorconstruction.html" title="VectorConstruction"><code>VectorConstruction</code></a>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-seriesconstruction-1.html">SeriesConstruction<'K></a>
          </td>
          <td class="xmldoc">
          <p>Represents a pair of index and vector construction
(many of the index operations take/return an index together with a construction
command that builds a vector matching with the index, so this type alias
makes this more obvious)</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Indices.Linear Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-linear-linearaddressoperations.html">LinearAddressOperations</a>
          </td>
          <td class="xmldoc">
          <p>Implements address operations for linear addressing</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-linear-linearindex-1.html">LinearIndex<'K></a>
          </td>
          <td class="xmldoc">
          <p>An index that maps keys <code>K</code> to offsets <a href="deedle-addressing-address.html" title="Address"><code>Address</code></a>. The keys cannot be duplicated.
The construction checks if the keys are ordered (using the provided or the default
comparer for <code>K</code>) and disallows certain operations on unordered indices.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-linear-linearindexbuilder.html">LinearIndexBuilder</a>
          </td>
          <td class="xmldoc">
          <p>Index builder object that is associated with <code>LinearIndex&lt;K&gt;</code> type. The builder
provides operations for manipulating linear indices (and the associated vectors).</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-linear-linearrangeindex-1.html">LinearRangeIndex<'K></a>
          </td>
          <td class="xmldoc">
          <p>A virtual index that represents a subrange of a specified index. This is useful for
windowing operations where we do not want to allocate a new index for each window.
This index can be cheaply constructed and it implements many of the standard functions
without actually allocating the index (e.g. KeyCount, KeyAt, IsEmpty). For more
complex index manipulations (including lookup), an actual index is constructed lazily.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Indices.Virtual Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-virtual-virtualindexbuilder.html">VirtualIndexBuilder</a>
          </td>
          <td class="xmldoc">
          <p>Implements <a href="deedle-indices-iindexbuilder.html" title="IIndexBuilder"><code>IIndexBuilder</code></a> interface for BigDeedle. This directly implements operations that can
be implemented on virtual vectors (mostly merging, slicing) and for other operations, it calls
ordinary <a href="deedle-indices-linear-linearindexbuilder.html" title="LinearIndexBuilder"><code>LinearIndexBuilder</code></a>. The resulting <a href="deedle-vectors-vectorconstruction.html" title="VectorConstruction"><code>VectorConstruction</code></a> corresponds to the addressing
scheme of the returned index (i.e. if we return virtual, we expect to build virtual vector; if
we materialize, the vector builder also has to materialize).</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-virtual-virtualorderedindex-1.html">VirtualOrderedIndex<'K></a>
          </td>
          <td class="xmldoc">
          <p>Represents an ordered index based on data provided by a virtual source.
The index can be used by BigDeedle virtual frames and series, without accessing
all data from the data source.</p>
<p>The index only evaluates the full key collection when needed. Most of the actual
work is delegated to the <code>IVirtualVectorSource&lt;'K&gt;</code> value passed in the constructor.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-virtual-virtualordinalindex.html">VirtualOrdinalIndex</a>
          </td>
          <td class="xmldoc">
          <p>Represents an ordinal index based on addressing provided by a virtual source.
The index can be used by BigDeedle virtual frames and series, without accessing
all data from the data source.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Internal Namespace</h2>
    <div>
      <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-array.html">Array</a>
          </td>
          <td class="xmldoc">
          <p>This module contains additional functions for working with arrays.
<code>Deedle.Internals</code> is opened, it extends the standard <a href="deedle-internal-array.html" title="Array"><code>Array</code></a> module.</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-list.html">List</a>
          </td>
          <td class="xmldoc">
          <p>This module contains additional functions for working with lists.</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-missingvalues.html">MissingValues</a>
          </td>
          <td class="xmldoc">
          <p>Utility functions for identifying missing values. The <code>isNA</code> function
can be used to test whether a value represents a missing value - this includes
the <code>null</code> value, <code>Nullable&lt;T&gt;</code> value with <code>HasValue = false</code> and
<code>Single.NaN</code> as well as <code>Double.NaN</code>.</p>
<p>The functions in this module are not intended to be called directly.</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-readonlycollection.html">ReadOnlyCollection</a>
          </td>
          <td class="xmldoc">
          <p>Provides helper functions for working with <code>ReadOnlyCollection&lt;T&gt;</code> similar to those
in the <a href="deedle-internal-array.html" title="Array"><code>Array</code></a> module. Most importantly, F# 3.0 does not know that array implements
<code>IList&lt;T&gt;</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-seq.html">Seq</a>
          </td>
          <td class="xmldoc">
          <p>This module contains additional functions for working with sequences.
<code>Deedle.Internals</code> is opened, it extends the standard <a href="deedle-internal-seq.html" title="Seq"><code>Seq</code></a> module.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Keys Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-keys-customkey.html">CustomKey</a>
          </td>
          <td class="xmldoc">
          <p>Helper type that can be used to get <a href="deedle-keys-icustomkey.html" title="ICustomKey"><code>ICustomKey</code></a> for any object (including objects
that actually implement the interface and tuples)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-keys-icustomkey.html">ICustomKey</a>
          </td>
          <td class="xmldoc">
          <p>Represents a special hierarchical key. This is mainly used in pretty printing (where we want to
get parts of the keys based on levels. <code>CustomKey.Get</code> provides a way of getting <a href="deedle-keys-icustomkey.html" title="ICustomKey"><code>ICustomKey</code></a>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-keys-simplelookup-1.html">SimpleLookup<'T></a>
          </td>
          <td class="xmldoc">
          <p>Implements a simple lookup that matches any multi-level key against a specified array of
optional objects (that represent missing/set parts of a key)</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Math Namespace</h2>
    <!-- If there is more than 1 category in the type, generate TOC -->
    <ul>
        <li><a href="#section7_0">Financial Analysis</a></li>            
        <li><a href="#section7_1">Linear Algebra</a></li>            
        <li><a href="#section7_2">Matrix conversions and operators</a></li>            
        <li><a href="#section7_3">Statistical Analysis</a></li>            
        <li><a href="#section7_4">Vector conversions and operators</a></li>            
        <li><a href="#section7_5">Other namespace members</a></li>            
    </ul>
      <h3><a class="anchor" name="section7_0" href="#section7_0">Financial Analysis</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-math-finance.html">Finance</a>
          </td>
          <td class="xmldoc">
          <p>Financial analysis</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section7_1" href="#section7_1">Linear Algebra</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-math-linearalgebra.html">LinearAlgebra</a>
          </td>
          <td class="xmldoc">
          <p>Linear algebra on frame using MathNet.Numerics library.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section7_2" href="#section7_2">Matrix conversions and operators</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-math-frame.html">Frame</a>
          </td>
          <td class="xmldoc">
          <p>Frame to matrix conversion</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-math-frameextensions.html">FrameExtensions</a>
          </td>
          <td class="xmldoc">
          <p>Extension of Frame<'R, 'C></p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-math-matrix.html">Matrix</a>
          </td>
          <td class="xmldoc">
          <p>Matrix conversions and operators between Frame and Series</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-math-matrixextensions.html">MatrixExtensions</a>
          </td>
          <td class="xmldoc">
          <p>Extension of Matrix<float></p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-math-seriesextensions.html">SeriesExtensions</a>
          </td>
          <td class="xmldoc">
          <p>Extension of Series<'C, float></p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section7_3" href="#section7_3">Statistical Analysis</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-math-correlationmethod.html">CorrelationMethod</a>
          </td>
          <td class="xmldoc">
          <p>Correlation method (Pearson or Spearman)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-math-stats.html">Stats</a>
          </td>
          <td class="xmldoc">
          <p>Statistical analysis using MathNet.Numerics</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section7_4" href="#section7_4">Vector conversions and operators</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-math-vectorextensions.html">VectorExtensions</a>
          </td>
          <td class="xmldoc">
          <p>Extension of Vector<float></p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
      <h3><a class="anchor" name="section7_5" href="#section7_5">Other namespace members</a></h3>    
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-math-series.html">Series</a>
          </td>
          <td class="xmldoc">
          
          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-math-statsinternal.html">StatsInternal</a>
          </td>
          <td class="xmldoc">
          
          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Ranges Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-ranges-irangekeyoperations-1.html">IRangeKeyOperations<'TKey></a>
          </td>
          <td class="xmldoc">
          <p>A set of operations on keys that you need to implement in order to use the
<code>Ranges&lt;'TKey&gt;</code> type. The <code>'TKey</code> type is typically the key of a BigDeedle
series. It can represent different things, such as:</p>
<ul>
<li><code>int64</code> - if you have ordinally indexed series</li>
<li><code>Date</code> (of some sort) - if you have daily time series</li>
<li><code>DateTimeOffset</code> - if you have time series with DTO keys</li>
</ul>
<p>The operations need to implement the <em>right</em> thing based on the logic of the
keys. So for example if you have one data point every hour, <code>IncrementBy</code> should
add the appropriate number of hours. Or if you have keys as business days, the
<code>IncrementBy</code> operation should add a number of business days (that is, the
operations may be simple numerical addition, but may contain more logic).</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-ranges-ranges-1.html">Ranges<'T></a>
          </td>
          <td class="xmldoc">
          <p>Represents a sub-range of an ordinal index. The range can consist of
multiple blocks, i.e. [ 0..9; 20..29 ]. The pairs represent indices
of first and last element (inclusively) and we also keep size so that
we do not have to recalculate it.</p>
<p>For more information, see also the documentation for the <code>Ranges</code> module.</p>


          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-ranges-ranges.html">Ranges</a>
          </td>
          <td class="xmldoc">
          <p>Provides F# functions for working with the <code>Ranges&lt;'T&gt;</code> type. Note that
most of the functions are also exposed as members. The terminology in the
functions below is:</p>
<ul>
<li><strong>offset</strong> refers to an absolute <code>int64</code> offset of a key in the range</li>
<li><strong>key</strong> refers to a key value of type <code>'T</code></li>
</ul>
<p>Say, you have daily range <code>[ (2015-01-01, 2015-01-10); (2015-02-01, 2015-02-10) ]</code>.
Then, the keys are the dates and the offsets are 0 .. 9 for the first part and
10 .. 19 for the second part.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Vectors Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-ibinarytransform.html">IBinaryTransform</a>
          </td>
          <td class="xmldoc">
          <p>Represent a transformation that is applied when combining two vectors (because
we are combining untyped <a href="deedle-ivector.html" title="IVector"><code>IVector</code></a> values, the transformation is also untyped)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-inarytransform.html">INaryTransform</a>
          </td>
          <td class="xmldoc">
          <p>Represent a tranformation that is applied when combining N vectors
(This follows exactly the same pattern as <a href="deedle-vectors-ibinarytransform.html" title="IBinaryTransform"><code>IBinaryTransform</code></a>)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-irowreadertransform.html">IRowReaderTransform</a>
          </td>
          <td class="xmldoc">
          <p>When an <a href="deedle-vectors-inarytransform.html" title="INaryTransform"><code>INaryTransform</code></a> implements this interface, it is a special well-known
transformation that creates a <em>row reader</em> vector to be used in <code>frame.Rows</code>.
(See the implementation in the <code>Build</code> operation in <code>ArrayVector.fs</code>)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-ivectorbuilder.html">IVectorBuilder</a>
          </td>
          <td class="xmldoc">
          <p>Represents an object that can construct vector values by processing
the "mini-DSL" representation <a href="deedle-vectors-vectorconstruction.html" title="VectorConstruction"><code>VectorConstruction</code></a>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-knownlocation.html">KnownLocation</a>
          </td>
          <td class="xmldoc">
          <p>An <a href="deedle-ivectorlocation.html" title="IVectorLocation"><code>IVectorLocation</code></a> created from a known address and offset
(typically used in LinearIndex/ArrayVector where both are the same)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vector.html">Vector</a>
          </td>
          <td class="xmldoc">
          <p>Type that provides access to creating vectors (represented as arrays)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectorconstruction.html">VectorConstruction</a>
          </td>
          <td class="xmldoc">
          <p>A "mini-DSL" that describes construction of a vector. Vector can be constructed
from various range operations (relocate, drop, slicing, appending), by combination
of two vectors or by taking a vector from a list of variables.</p>
<p>Notably, vectors can only be constructed from other vectors of the same type
(the <code>Combine</code> operation requires this - even though that one could be made more general).
This is an intentional choice to make the representation simpler.</p>
<p>Logically, when we apply some index operation, we should get back a polymorphic vector
construction (<code>\forall T. VectorConstruction&lt;T&gt;</code>) that can be applied to variuous
different vector types. That would mean adding some more types, so we just model vector
construction as an untyped operation and the typing is resquired by the <code>Build</code> method
of the vector builder.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectordata-1.html">VectorData<'T></a>
          </td>
          <td class="xmldoc">
          <p>Provides a way to get the data of an arbitrary vector. This is a concrete type used
by functions that operate on vectors (like <code>Series.sum</code>, etc.). The vector may choose
to return the data as <a href="deedle-internal-readonlycollection.html" title="ReadOnlyCollection"><code>ReadOnlyCollection</code></a> (with or without N/A values) which is more
efficient to use or as a lazy sequence (slower, but more general).</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectorfillmissing.html">VectorFillMissing</a>
          </td>
          <td class="xmldoc">
          <p>Specifies how to fill missing values in a vector (when using the
<code>VectorConstruction.FillMissing</code> command). This can only fill missing
values using strategy that does not require access to index keys -
either using constant or by propagating values.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectorhole.html">VectorHole</a>
          </td>
          <td class="xmldoc">
          <p>Representes a "variable" in the mini-DSL below</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectorlisttransform.html">VectorListTransform</a>
          </td>
          <td class="xmldoc">
          <p>A transformation on vector(s) can specified as binary or as N-ary. A binary transformation
can be applied to N elements using <code>List.reduce</code>, but allows optimizations.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Vectors.ArrayVector Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-arrayvector-arrayvector-1.html">ArrayVector<'T></a>
          </td>
          <td class="xmldoc">
          <p>Vector that stores data in an array. The data is stored using the
<code>ArrayVectorData&lt;'T&gt;</code> type (discriminated union)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-arrayvector-arrayvectorbuilder.html">ArrayVectorBuilder</a>
          </td>
          <td class="xmldoc">
          <p>Implements a builder object (<a href="deedle-vectors-ivectorbuilder.html" title="IVectorBuilder"><code>IVectorBuilder</code></a>) for creating
vectors of type <code>ArrayVector&lt;'T&gt;</code>. This includes operations such as
appending, relocating values, creating vectors from arrays etc.
The vector builder automatically switches between the two possible
representations of the vector - when a missing value is present, it
uses <code>ArrayVectorData.VectorOptional</code>, otherwise it uses
<code>ArrayVectorData.VectorNonOptional</code>.</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Vectors.Virtual Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-virtual-delayedlocation.html">DelayedLocation</a>
          </td>
          <td class="xmldoc">
          <p>Represents a vector location that calculates the offset using
address operations as needed (typically, we want to avoid this
because it might be slow)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-virtual-ivirtualvectorsource.html">IVirtualVectorSource</a>
          </td>
          <td class="xmldoc">
          <p>Non-generic part of the <code>IVirtualVectorSource&lt;'V&gt;</code> interface, which
provides some basic information about the virtualized data source</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-virtual-ivirtualvectorsource-1.html">IVirtualVectorSource<'V></a>
          </td>
          <td class="xmldoc">
          <p>Represents a data source for Big Deedle. The interface is used both as a representation
of data source for <code>VirtualVector</code> (this file) and <code>VirtualIndex</code> (another file). The
index uses <code>Length</code> and <code>ValueAt</code> to perform binary search when looking for a key; the
vector simply provides an access to values using <code>ValueAt</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-virtual-ivirtualvectorsourceoperation-1.html">IVirtualVectorSourceOperation<'R></a>
          </td>
          <td class="xmldoc">
          <p>A helper type used by non-generic <a href="deedle-vectors-virtual-ivirtualvectorsource.html" title="IVirtualVectorSource"><code>IVirtualVectorSource</code></a> to invoke generic
operations that require generic <code>IVirtualVectorSource&lt;'T&gt;</code> as an argument.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-virtual-rangesaddressoperations-1.html">RangesAddressOperations<'TKey></a>
          </td>
          <td class="xmldoc">
          <p>In BigDeedle, we often use <code>Ranges&lt;'T&gt;</code> to represent the address range obtained as a result
of slicing and merging frames &amp; series. This implements <a href="deedle-addressing-iaddressoperations.html" title="IAddressOperations"><code>IAddressOperations</code></a> for <code>Ranges&lt;'T&gt;</code>.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-virtual-virtualaddressingscheme.html">VirtualAddressingScheme</a>
          </td>
          <td class="xmldoc">
          <p>Represents an addressing scheme associated to virtual vectors. The addresses
may be partitioned differently (for different data sources), so this carries
an "id" of the data source (to make sure we don't try to mix mismatching data
sources)</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-virtual-virtualvector-1.html">VirtualVector<'V></a>
          </td>
          <td class="xmldoc">
          <p>Creates an <code>IVector&lt;'T&gt;</code> implementation that provides operations for accessing
data in <a href="deedle-vectors-virtual-ivirtualvectorsource.html" title="IVirtualVectorSource"><code>IVirtualVectorSource</code></a>. This mostly just calls <code>ValueAt</code> to read data.</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-virtual-virtualvectorbuilder.html">VirtualVectorBuilder</a>
          </td>
          <td class="xmldoc">
          <p>Implements a builder object (<a href="deedle-vectors-ivectorbuilder.html" title="IVectorBuilder"><code>IVectorBuilder</code></a>) for creating vectors of type <code>VirtualVector&lt;'T&gt;</code>.
This can do a few things without evaluating vectors (merging, slicing). For other operations
the builder needs to materialize the vector and call <a href="deedle-vectors-arrayvector-arrayvectorbuilder.html" title="ArrayVectorBuilder"><code>ArrayVectorBuilder</code></a>.</p>


          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-vectors-virtual-virtualvectorsource.html">VirtualVectorSource</a>
          </td>
          <td class="xmldoc">
          <p>Module that implements various helper operations over <a href="deedle-vectors-virtual-ivirtualvectorsource.html" title="IVirtualVectorSource"><code>IVirtualVectorSource</code></a> type</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>Deedle.Virtual Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-virtual-indexutils.html">IndexUtils</a>
          </td>
          <td class="xmldoc">
          <p>Helpers that can be used when implementing Lookup</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-virtual-virtual.html">Virtual</a>
          </td>
          <td class="xmldoc">
          <p>Provides static methods for creating virtual series and virtual frames.
Those provide necessary wrapping around <a href="deedle-vectors-virtual-ivirtualvectorsource.html" title="IVirtualVectorSource"><code>IVirtualVectorSource</code></a> values</p>


          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-virtual-indexutilsmodule.html">IndexUtilsModule</a>
          </td>
          <td class="xmldoc">
          
          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>FSharp.Data Namespace</h2>
    <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="fsharp-data-http.html">Http</a>
          </td>
          <td class="xmldoc">
          <p>Utilities for working with network via HTTP. Includes methods for downloading
resources with specified headers, query parameters and HTTP body</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="fsharp-data-httprequestbody.html">HttpRequestBody</a>
          </td>
          <td class="xmldoc">
          <p>The body to send in an HTTP request</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="fsharp-data-httpresponse.html">HttpResponse</a>
          </td>
          <td class="xmldoc">
          <p>The response returned by an HTTP request</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="fsharp-data-httpresponsebody.html">HttpResponseBody</a>
          </td>
          <td class="xmldoc">
          <p>The response body returned by an HTTP request</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="fsharp-data-httpresponsewithstream.html">HttpResponseWithStream</a>
          </td>
          <td class="xmldoc">
          <p>The response returned by an HTTP request with direct access to the response stream</p>


          </td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="fsharp-data-multipartitem.html">MultipartItem</a>
          </td>
          <td class="xmldoc">
          
          </td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="fsharp-data-httpcontenttypes.html">HttpContentTypes</a>
          </td>
          <td class="xmldoc">
          <p>Constants for common HTTP content types</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="fsharp-data-httpencodings.html">HttpEncodings</a>
          </td>
          <td class="xmldoc">
          <p>Constants for common HTTP encodings</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="fsharp-data-httpmethod.html">HttpMethod</a>
          </td>
          <td class="xmldoc">
          <p>The method to use in an HTTP request</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="fsharp-data-httprequestheaders.html">HttpRequestHeaders</a>
          </td>
          <td class="xmldoc">
          <p>Headers that can be sent in an HTTP request</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="fsharp-data-httpresponseheaders.html">HttpResponseHeaders</a>
          </td>
          <td class="xmldoc">
          <p>Headers that can be received in an HTTP response</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="fsharp-data-httpstatuscodes.html">HttpStatusCodes</a>
          </td>
          <td class="xmldoc">
          <p>Status codes that can be received in an HTTP response</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="fsharp-data-mimetypes.html">MimeTypes</a>
          </td>
          <td class="xmldoc">
          
          </td>
        </tr>
    </tbody>
  </table>

    </div>
  <h2>FSharp.Data.Runtime Namespace</h2>
    <div>
      <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="fsharp-data-runtime-io.html">IO</a>
          </td>
          <td class="xmldoc">
          <p>Helper functions called from the generated code for working with files</p>


          </td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="fsharp-data-runtime-nameutils.html">NameUtils</a>
          </td>
          <td class="xmldoc">
          <p>Tools for generating nice member names that follow F# &amp; .NET naming conventions</p>


          </td>
        </tr>
    </tbody>
  </table>

    </div>

        </div>
        <div class="span3">
          <a href="https://fslab.org/Deedle/index.html">
            <img src="https://fslab.org/Deedle/images/logo.png" style="width:140px;height:140px;margin:10px 0px 0px 35px;border-style:none;" />
          </a>

          <ul class="nav nav-list" id="menu">
            <li class="nav-header">Deedle</li>
            <li><a href="https://fslab.org/Deedle/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="https://nuget.org/packages/Deedle">Get Library via NuGet</a></li>
            <li><a href="http://github.com/fslaborg/Deedle">Source Code on GitHub</a></li>
            <li><a href="http://github.com/fslaborg/Deedle/blob/master/LICENSE.md">License (BSD)</a></li>
            <li><a href="https://fslab.org/Deedle/RELEASE_NOTES.html">Release Notes</a></li>
            <li><a href="https://fslab.org/Deedle/design.html">Design Notes</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/deedle">Ask a Question!</a></li>
            
            <li class="nav-header">Using from F#</li>
            <li>
              <a href="https://fslab.org/Deedle/tutorial.html">Quick Start Tutorial</a>
            </li>
            <li>
              <a href="https://fslab.org/Deedle/series.html">Working with Time Series</a>
            </li>
            <li>
              <a href="https://fslab.org/Deedle/frame.html">Working with Data Frames</a>
            </li>
            <li>
              <a href="https://fslab.org/Deedle/stats.html">Statistics &amp; Calculations</a>
            </li>
            <li>
              <a href="https://fslab.org/Deedle/rinterop.html">Using Deedle with R</a>
            </li>

            <li class="nav-header">Using from C#</li>
            <li><a href="https://fslab.org/Deedle/csharpintro.html">Getting Started</a></li>
            <li>
              <a href="https://fslab.org/Deedle/csharpseries.html">Working with Data Series</a>
            </li>
            <li>
              <a href="https://fslab.org/Deedle/csharpframe.html">Working with Data Frames</a>
            </li>

            <li class="nav-header">Core Documentation</li>
            <li><a href="https://fslab.org/Deedle/reference/index.html">API Reference</a></li>
            <li class="divider"></li>
            <li><a href="https://fslab.org/Deedle/reference/deedle-seriesmodule.html">Series Module</a></li>
            <li><a href="https://fslab.org/Deedle/reference/deedle-framemodule.html">Frame Module</a></li>
            <li><a href="https://fslab.org/Deedle/reference/deedle-stats.html">Stats Module</a></li>
            
            <li class="nav-header">Math Documentation</li>            
            <li><a href="https://fslab.org/Deedle/reference/deedle-math-linearalgebra.html">Linear Algebra Module</a></li>
            <li><a href="https://fslab.org/Deedle/reference/deedle-math-stats.html">Stats Module</a></li>
            <li><a href="https://fslab.org/Deedle/reference/deedle-math-finance.html">Finance Module</a></li>             
            <li class="nav-header">Samples</li>
            <li><a href="https://fslab.org/Deedle/lazysource.html">Lazy Data Loading</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/fslaborg/Deedle"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
    <script>
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
      })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
      ga('create', 'UA-45379232-1', 'bluemountaincapital.github.io');
      ga('send', 'pageview');
    </script>
  </body>
</html>